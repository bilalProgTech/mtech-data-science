# -*- coding: utf-8 -*-
"""MTech-DS-AI-BilalHungund-D013-M2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/167aIshpLpcktbOqZovrKEAQvSdPo_qXb

# Q.1)
"""

!wget https://archive.ics.uci.edu/ml/machine-learning-databases/00275/Bike-Sharing-Dataset.zip
!unzip \*.zip  && rm *.zip

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

data = pd.read_csv('/content/hour.csv')
data.head()

data.shape

X = data.drop(['instant', 'dteday', 'cnt'], axis=1)
y = data['cnt']
X.head()

from tensorflow.keras.optimizers import RMSprop, SGD, Adamax, Adagrad
import tensorflow as tf
print(tf.__version__)

from sklearn.model_selection import train_test_split
x_train, x_val, y_train, y_val = train_test_split(X, y, test_size=0.2)

"""Ans 1.1 & 1.2)

1.   Using batch normalization makes the network more stable during training.
2.   Batch normalization normalizes the output of a previous activation layer by subtracting the batch mean and dividing by the batch standard deviation.
3. kernel_regularizer: is used as regularization method to avoid problem of overfit
4. activation function used is RELU
5. Metrics used for measure is MAE, Mean Absolute Error
"""

tf.keras.backend.clear_session()
model = tf.keras.models.Sequential([
    tf.keras.layers.Input(shape=(X.shape[1],)),
    tf.keras.layers.BatchNormalization(),
    tf.keras.layers.Dense(50, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.001)),
    tf.keras.layers.Dense(30, activation='relu'),
    tf.keras.layers.BatchNormalization(),
    tf.keras.layers.Dense(10, activation='relu', kernel_regularizer=tf.keras.regularizers.l2(0.001)),
    tf.keras.layers.Dense(5, activation='relu'),
    tf.keras.layers.Dense(1)
])
model.summary()

model.compile(optimizer = "adam", 
              loss = 'mse', 
              metrics = ['mae'])

print_weights = tf.keras.callbacks.LambdaCallback(on_epoch_end=lambda batch, logs: print(model.layers[0].get_weights()))

"""Ans 1.4)"""

history = model.fit(
    x_train, 
    y_train, 
    epochs = 20, 
    validation_data = (x_val, y_val), callbacks = [print_weights]
)

score = model.evaluate(x_val, y_val, verbose=1)

print("Test RMSE:", np.sqrt(score[1]))
print("Test MAE:", score[0])

from sklearn.metrics import r2_score
r2_score(y_val, model.predict(x_val))

import matplotlib.pyplot as plt
mae = history.history['mae']
val_mae = history.history['val_mae']
rmse = np.sqrt(history.history['loss'])
val_rmse = np.sqrt(history.history['val_loss'])

epochs = range(len(mae))

plt.plot(epochs, mae, 'r', label='Training MAE')
plt.plot(epochs, val_mae, 'b', label='Validation MAE')
plt.title('Training and Validation MAE')
plt.legend()
plt.figure()

plt.plot(epochs, rmse, 'r', label='Training RMSE')
plt.plot(epochs, val_rmse, 'b', label='Validation RMSE')
plt.title('Training and Validation RMSE')
plt.legend()
plt.figure()

plt.show()

"""Ans 1.3)"""

print(model.layers[3].weights)

"""# Q.2)"""

def findNext(grid, i, j):
  #Finding next cell whose value is 0 to fill values
  for x in range(i,9):
    for y in range(j,9):
      if grid[x][y] == 0:
        return x,y
  for x in range(0,9):
    for y in range(0,9):
      if grid[x][y] == 0:
        return x,y
  return -1,-1


def checkRowCloumn(grid, i, j, n):
  #check that the same number is not in row or column or same box 
  rowCheck = all([n != grid[i][x] for x in range(9)])
  if rowCheck:
    columnCheck = all([n != grid[x][j] for x in range(9)])
    if columnCheck:
      topX, topY = 3 *(i//3), 3 *(j//3) #floored quotient should be used here. 
      for x in range(topX, topX+3):
        for y in range(topY, topY+3):
          if grid[x][y] == n:
            return False
      return True
  return False


def solveProblem(grid, i=0, j=0):
  i,j = findNext(grid, i, j)
  if i == -1:
    return True
  for n in range(1,10):
    if checkRowCloumn(grid,i,j,n):
      grid[i][j] = n
      if solveProblem(grid, i, j):
        return True
        # Undo the current cell for backtracking
      grid[i][j] = 0
  return False


def printGrid():
    for i in range(len(grid_input)):
        line = ""
        if i == 3 or i == 6:
            print("---------------------")
        for j in range(len(grid_input[i])):
            if j == 3 or j == 6:
                line += "| "
            line += str(grid_input[i][j])+" "
        print(line)

grid_input = [[5, 3, 0, 0, 7, 0, 0, 0, 0], 
         [6, 0, 0, 1, 9, 5, 0, 0, 0], 
         [0, 9, 8, 0, 0, 0, 0, 6, 0], 
         [8, 0, 0, 0, 6, 0, 0, 0, 3], 
         [4, 0, 0, 8, 0, 3, 0, 0, 1], 
         [7, 0, 0, 0, 2, 0, 0, 0, 6], 
         [0, 6, 0, 0, 0, 0, 2, 8, 0], 
         [0, 0, 0, 4, 1, 9, 0, 0, 5], 
         [0, 0, 0, 0, 8, 0, 0, 7, 9]]
solveProblem(grid_input)
printGrid()